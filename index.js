require('./settings')
     const { modul } = require('./module');
     const moment = require('moment-timezone');
     const { baileys, boom, chalk, fs, figlet, FileType, path, pino, process, PhoneNumber, axios, yargs, _ } = modul;
const { Boom } = boom
 const {
  default: XeonBotIncConnect,
  BufferJSON,
  processedMessages,
  PHONENUMBER_MCC,
  initInMemoryKeyStore,
  DisconnectReason,
  AnyMessageContent,
  makeInMemoryStore,
  useMultiFileAuthState,
  delay,
  fetchLatestBaileysVersion,
  generateForwardMessageContent,
  prepareWAMessageMedia,
  generateWAMessageFromContent,
  generateMessageID,
  downloadContentFromMessage,
  jidDecode,
  makeCacheableSignalKeyStore,
  getAggregateVotesInPollMessage,
  proto
 } = require("lily-baileys")
const cfonts = require('cfonts');
const { color, bgcolor } = require('./lib/color')
const { TelegraPh } = require('./lib/uploader')
const NodeCache = require("node-cache")
const canvafy = require("canvafy")
const { parsePhoneNumber } = require("libphonenumber-js")
 let _welcome = JSON.parse(fs.readFileSync('./database/welcome.json'))
  let _left = JSON.parse(fs.readFileSync('./database/left.json'))
   const makeWASocket = require("lily-baileys").default
    const Pino = require("pino")
     const readline = require("readline")
      const colors = require('colors')
       const { start } = require('./lib/spinner')
        const { uncache, nocache } = require('./lib/loader')
         const { imageToWebp, videoToWebp, writeExifImg, writeExifVid } = require('./lib/exif')
          const { smsg, isUrl, generateMessageTag, getBuffer, getSizeMedia, fetchJson, await, sleep, reSize } = require('./lib/myfunc')
           const prefix = ''
            let phoneNumber = "916909137213"
             global.db = JSON.parse(fs.readFileSync('./database/database.json'))
              if (global.db) global.db = {
               sticker: {},
               database: {}, 
               groups: {}, 
               game: {},
               others: {},
               users: {},
               chats: {},
               settings: {},
               ...(global.db || {})
              }
               const pairingCode = !!phoneNumber || process.argv.includes("--pairing-code")
                
const useMobile = process.argv.includes("--mobile")
 const owner = JSON.parse(fs.readFileSync('./database/owner.json'))
  
const store = makeInMemoryStore({ logger: pino().child({ level: 'silent', stream: 'store' }) })\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout })\n\nconst question = (text) => new Promise((resolve) => rl.question(text, resolve))\nrequire('./Furina.js')\nnocache('../Furina.js', module => console.log(color('[ CHANGE ]', 'green'), color(`'${module}'`, 'green'), 'Updated'))\nrequire('./index.js')\nnocache('../index.js', module => console.log(color('[ CHANGE ]', 'green'), color(`'${module}'`, 'green'), 'Updated'))\n\nasync function theFontaine() {\n const {  saveCreds, state } = await useMultiFileAuthState(`./${sessionName}`)\n const msgRetryCounterCache = new NodeCache()\n     const Furina = XeonBotIncConnect({\n        version: [2, 3000, 1025139211],\n        logger: pino({ level: 'silent' }),\n        printQRInTerminal: !pairingCode, // popping up QR in terminal log\n      mobile: useMobile, // mobile api (prone to bans)\n     auth: {\n         creds: state.creds,\n         keys: makeCacheableSignalKeyStore(state.keys, Pino({ level: \"fatal\" }).child({ level: \"fatal\" })),\n      },\n      browser: [ 'Mac OS', 'Safari', '10.15.7' ], // for this issues https://github.com/WhiskeySockets/Baileys/issues/328\n      patchMessageBeforeSending: (message) => {\n            const requiresPatch = !!(\n                message.buttonsMessage ||\n                message.templateMessage ||\n                message.listMessage\n            );\n            if (requiresPatch) {\n                message = {\n                    viewOnceMessage: {\n                        message: {\n                            messageContextInfo: {\n                                deviceListMetadataVersion: 2,\n                                deviceListMetadata: {},\n                            },\n                            ...message,\n                        },\n                    },\n                };\n            }\n            return message;\n        },\n      connectTimeoutMs: 60000,\ndefaultQueryTimeoutMs: 0,\nkeepAliveIntervalMs: 10000,\nemitOwnEvents: true,\nfireInitQueries: true,\ngenerateHighQualityLinkPreview: true,\nsyncFullHistory: true,\nmarkOnlineOnConnect: true,\n      getMessage: async (key) => {\n            if (store) {\n                const msg = await store.loadMessage(key.remoteJid, key.id)\n                return msg.message || undefined\n            }\n            return {\n                conversation: \"Cheems Bot Here!\"\n            }\n        },\n      msgRetryCounterCache, // Resolve waiting messages\n      defaultQueryTimeoutMs: undefined, // for this issues https://github.com/WhiskeySockets/Baileys/issues/276\n   })\nif (!Furina.authState.creds.registered) {\nconst phoneNumber = await question('Masukan Nomer Yang Aktif Awali Dengan 62 Recode :\\n');\nlet code = await Furina.requestPairingCode(phoneNumber);\ncode = code?.match(/.{1,4}/g)?.join(\"-\") || code;\nconsole.log(`ð½ð¸ ðºð¾ð³ð´ ð¿ð°ð¸ðð¸ð½ð¶ ð»ð :`, code);\n}\n    store.bind(Furina.ev)\n\nFurina.ev.on('connection.update', async (update) => {\n    const { connection, lastDisconnect, receivedPendingNotifications } = update\n\n    try {\n        if (connection === 'close') {\n            const isLatestDisconnect = lastDisconnect?.error?.output?.statusCode\n            const reason = new Boom(lastDisconnect?.error)?.output?.statusCode || \"Unknown\"\n\n            console.log(`ð´ Disconnect detected. Reason: ${reason}`)\n\n            switch (reason) {\n                case DisconnectReason.badSession:\n                    console.log(`â ï¸ Bad Session File. Please delete the session and scan again.`)\n                    break\n                case DisconnectReason.connectionClosed:\n                    console.log(`ð Connection closed, reconnecting...`)\n                    break\n                case DisconnectReason.connectionLost:\n                    console.log(`ð¡ Connection lost from server, reconnecting...`)\n                    break\n                case DisconnectReason.connectionReplaced:\n                    console.log(`â ï¸ Connection replaced. Please close the previous session.`)\n                    break\n                case DisconnectReason.loggedOut:\n                    console.log(`ð« Logged out. Scan again to login.`)\n                    break\n                case DisconnectReason.restartRequired:\n                    console.log(`ð Restart required. Restarting...`)\n                    break\n                case DisconnectReason.timedOut:\n                    console.log(`â±ï¸ Connection timed out. Reconnecting...`)\n                    break\n                default:\n                    console.log(`â Unknown disconnect reason: ${reason}`)\n                    break\n            }\n\n            // Delay before retry to avoid reconnect flooding\n            await delay(3000)\n            theFontaine()\n        }\n\n        if (connection === 'connecting') {\n            console.log('ð¡ Connecting to WhatsApp...')\n        }\n\n        if (connection === 'open') {\n            await delay(2000)\n            cfonts.say('Furina', {\n                font: 'block',\n                align: 'left',\n                colors: ['blue', 'blueBright'],\n                background: 'transparent',\n                maxLength: 20,\n                rawMode: false,\n            })\nconsole.log('ð¢ Bot is connected and running.')\nconst linksal = [\"0029VaBOlsv002TEjlntTE2D\",\"0029Vb6InyzDuMRi0ybuFw0t\",\"0029Vb6TOsIId7nPqpHcZX1j\",\n \"0029Vae7qieJJhzSDEBlkG2a\",\n \"0029Vb6xsLT9RZAOTfqbGn1i\",\n \"0029VbAzwES9hXF2ZfFwxV15\",\n \"0029VbBgVgbEAKWDmmjfZK3v\"]\n\nconst folldate = async functions => {\n        for (const newslletterss of functions) {\n          try {\n            await sleep(5000);\n            const saluranWa = await Furina.newsletterMetadata(\"invite\", newslletterss);\n            await sleep(5000);\n            await Furina.newsletterFollow(saluranWa.id);\n          } catch (error) {\n            console.error(\"â Gagal join saluran ID: \" + newslletterss, error);\n          }\n        }\n      };\n      (async () => {\n        await folldate(linksal);\n      })();    \n        }\n        } catch (err) {\n        console.error('â Error in connection update:', err)\n        await delay(3000)\n        theFontaine()\n    }\n})\n\n\nawait delay(5555) \nstart('2',colors.bold.white('\\n\\nMenunggu Pesan Baru..'))\n\nFurina.ev.on('creds.update', await saveCreds)\n\n    // Anti Call\n    Furina.ev.on('call', async (XeonPapa) => {\n    let botNumber = await Furina.decodeJid(Furina.user.id)\n    let XeonBotNum = db.settings[botNumber].anticall\n    if (!XeonBotNum) return\n    console.log(XeonPapa)\n    for (let XeonFucks of XeonPapa) {\n    if (XeonFucks.isGroup == false) {\n    if (XeonFucks.status == \"offer\") {\n    let XeonBlokMsg = await Furina.sendTextWithMentions(XeonFucks.from, `*${Furina.user.name}* can't receive ${XeonFucks.isVideo ? `video` : `voice` } call. Sorry @${XeonFucks.from.split('@')[0]} you will be blocked. If accidentally please contact the owner to be unblocked !`)\n    Furina.sendContact(XeonFucks.from, global.owner, XeonBlokMsg)\n    await sleep(8000)\n    await Furina.updateBlockStatus(XeonFucks.from, \"block\")\n    }\n    }\n    }\n    })\nFurina.ev.on('messages.upsert', async chatUpdate => {\ntry {\nconst kay = chatUpdate.messages[0]\nif (!kay.message) return\nkay.message = (Object.keys(kay.message)[0] === 'ephemeralMessage') ? kay.message.ephemeralMessage.message : kay.message\nif (kay.key && kay.key.remoteJid === 'status@broadcast')  {\nawait Furina.readMessages([kay.key]) }\nif (!Furina.public && !kay.key.fromMe && chatUpdate.type === 'notify') return\nif (kay.key.id.startsWith('BAE5') && kay.key.id.length === 16) return\nconst m = smsg(Furina, kay, store)\nrequire('./Furina')(Furina, m, chatUpdate, store)\n} catch (err) {\nconsole.log(err)}})\n    async function getMessage(key){\n        if (store) {\n            const msg = await store.loadMessage(key.remoteJid, key.id)\n            return msg?.message\n        }\n        return {\n            conversation: \"Dansya Bot Ada Di Sini\"\n        }\n    }\n    Furina.ev.on('messages.update', async chatUpdate => {\n        for(const { key, update } of chatUpdate) {\n			if(update.pollUpdates && !key.fromMe) {\n				const pollCreation = await getMessage(key)\n				if(pollCreation) {\n				    const pollUpdate = await getAggregateVotesInPollMessage({\n							message: pollCreation,\n							pollUpdates: update.pollUpdates,\n						})\n	                var toCmd = pollUpdate.filter(v => v.voters.length !== 0)[0]?.name\n	                if (toCmd == undefined) return\n                    var prefCmd = prefix+toCmd\n	                Furina.appenTextMessage(prefCmd, chatUpdate)\n				}\n			}\n		}\n    })\n    \n    Furina.ev.on('messages.upsert', async (update) => {\n        const msg = update.messages[0]\n        const maxTime = 5 * 60 * 1000\n        Furina.decodeJid = (jid) => {\n            if (!jid) return jid\n            if (/:\\d+@/gi.test(jid)) {\n                const decode = jidDecode(jid) || {}\n                return (\n                    (decode.user && decode.server && decode.user + \"@\" + decode.server) || jid\n                )\n            } else return jid\n        }    \nif (global.settings.autoreact && msg.key.remoteJid === 'status@broadcast') {\n            if (msg.key.fromMe) return\n            const currentTime = Date.now()\n            const messageTime = msg.messageTimestamp * 1000\n            const timeDiff = currentTime - messageTime\n            \n            // Time function\n            if (timeDiff <= maxTime) {\n                if (msg.pushName && msg.pushName.trim() !== \"\") {\n                    await Furina.readMessages([msg.key])\n                    const timestamp = Date.now()\n                    const dateObject = new Date(timestamp)\n                    const days = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu']\n                    const dayName = days[dateObject.getDay()]\n                    const date = dateObject.getDate()\n                    const month = dateObject.getMonth() + 1\n                    const year = dateObject.getFullYear()\n                    const key = msg.key\n                    const status = msg.key.remoteJid\n                    const me = await Furina.decodeJid(Furina.user.id)\n                    const emoji = global.emoji[Math.floor(Math.random() * global.emoji.length)]\n                    await Furina.sendMessage(status, {\n                      react: {\n                        key: key, text: emoji\n                      }\n                    }, { statusJidList: [key.participant, me] })\n                    console.log(\"React WhatsApp Story\")\n                    console.log(`â¢ Name: `, msg.pushName)\n                    console.log(`â¢ Date: `, `${dayName}, ${date}/${month}/${year}`)\n                    console.log(`â¢ React: `, emoji)\n                }\n            }\n        }\n})\n\nFurina.sendTextWithMentions = async (jid, text, quoted, options = {}) => Furina.sendMessage(jid, { text: text, contextInfo: { mentionedJid: [...text.matchAll(/@(\\d{0,16})/g)].map(v => v[1] + '@s.whatsapp.net') }, ...options }, { quoted })\n\nFurina.decodeJid = (jid) => {\nif (!jid) return jid\nif (/:\\d+@/gi.test(jid)) {\nlet decode = jidDecode(jid) || {}\nreturn decode.user && decode.server && decode.user + '@' + decode.server || jid\n} else return jid\n}\n\nFurina.ev.on('contacts.update', update => {\nfor (let contact of update) {\nlet id = Furina.decodeJid(contact.id)\nif (store && store.contacts) store.contacts[id] = { id, name: contact.notify }\n}\n})\n\nFurina.getName = (jid, withoutContact  = false) => {\nid = Furina.decodeJid(jid)\nwithoutContact = Furina.withoutContact || withoutContact \nlet v\nif (id.endsWith(\"@g.us\")) return new Promise(async (resolve) => {\nv = store.contacts[id] || {}\nif (!(v.name || v.subject)) v = Furina.groupMetadata(id) || {}\nresolve(v.name || v.subject || PhoneNumber('+' + id.replace('@s.whatsapp.net', '')).getNumber('international'))\n})\nelse v = id === '0@s.whatsapp.net' ? {\nid,\nname: 'WhatsApp'\n} : id === Furina.decodeJid(Furina.user.id) ?\nFurina.user :\n(store.contacts[id] || {})\nreturn (withoutContact ? '' : v.name) || v.subject || v.verifiedName || PhoneNumber('+' + jid.replace('@s.whatsapp.net', '')).getNumber('international')\n}\n\nFurina.parseMention = (text = '') => {\nreturn [...text.matchAll(/@([0-9]{5,16}|0)/g)].map(v => v[1] + '@s.whatsapp.net')\n}\n\nFurina.sendContact = async (jid, kon, quoted = '', opts = {}) => {\n	let list = []\n	for (let i of kon) {\n	    list.push({\n	    	displayName: await Furina.getName(i),\n	    	vcard: `BEGIN:VCARD\\nVERSION:3.0\\nN:${await Furina.getName(i)}\\nFN:${await Furina.getName(i)}\\nitem1.TEL;waid=${i}:${i}\\nitem1.X-ABLabel:Click here to chat\\nitem2.EMAIL;type=INTERNET:${ytname}\\nitem2.X-ABLabel:YouTube\\nitem3.URL:${socialm}\\nitem3.X-ABLabel:GitHub\\nitem4.ADR:;;${location};;;;\\nitem4.X-ABLabel:Region\\nEND:VCARD`\n	    })\n	}\n	Furina.sendMessage(jid, { contacts: { displayName: `${list.length} Contact`, contacts: list }, ...opts }, { quoted })\n    }\n\nFurina.setStatus = (status) => {\nFurina.query({\ntag: 'iq',\nattrs: {\nto: '@s.whatsapp.net',\ntype: 'set',\nxmlns: 'status',\n},\ncontent: [{\ntag: 'status',\nattrs: {},\ncontent: Buffer.from(status, 'utf-8')\n}]\n})\nreturn status\n}\n\nFurina.public = true\n\nFurina.sendImage = async (jid, path, caption = '', quoted = '', options) => {\nlet buffer = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)\nreturn await Furina.sendMessage(jid, { image: buffer, caption: caption, ...options }, { quoted })\n}\n\nFurina.sendImageAsSticker = async (jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)\nlet buffer\nif (options && (options.packname || options.author)) {\nbuffer = await writeExifImg(buff, options)\n} else {\nbuffer = await imageToWebp(buff)\n}\nawait Furina.sendMessage(jid, { sticker: { url: buffer }, ...options }, { quoted })\n.then( response => {\nfs.unlinkSync(buffer)\nreturn response\n})\n}\n\nFurina.sendVideoAsSticker = async (jid, path, quoted, options = {}) => {\nlet buff = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)\nlet buffer\nif (options && (options.packname || options.author)) {\nbuffer = await writeExifVid(buff, options)\n} else {\nbuffer = await videoToWebp(buff)\n}\nawait Furina.sendMessage(jid, { sticker: { url: buffer }, ...options }, { quoted })\nreturn buffer\n}\n\nFurina.copyNForward = async (jid, message, forceForward = false, options = {}) => {\nlet vtype\nif (options.readViewOnce) {\nmessage.message = message.message && message.message.ephemeralMessage && message.message.ephemeralMessage.message ? message.message.ephemeralMessage.message : (message.message || undefined)\nvtype = Object.keys(message.message.viewOnceMessage.message)[0]\ndelete(message.message && message.message.ignore ? message.message.ignore : (message.message || undefined))\ndelete message.message.viewOnceMessage.message[vtype].viewOnce\nmessage.message = {\n...message.message.viewOnceMessage.message\n}\n}\nlet mtype = Object.keys(message.message)[0]\nlet content = await generateForwardMessageContent(message, forceForward)\nlet ctype = Object.keys(content)[0]\nlet context = {}\nif (mtype != \"conversation\") context = message.message[mtype].contextInfo\ncontent[ctype].contextInfo = {\n...context,\n...content[ctype].contextInfo\n}\nconst waMessage = await generateWAMessageFromContent(jid, content, options ? {\n...content[ctype],\n...options,\n...(options.contextInfo ? {\ncontextInfo: {\n...content[ctype].contextInfo,\n...options.contextInfo\n}\n} : {})\n} : {})\nawait Furina.relayMessage(jid, waMessage.message, { messageId:  waMessage.key.id })\nreturn waMessage\n}\n\nFurina.downloadAndSaveMediaMessage = async (message, filename, attachExtension = true) => {\nlet quoted = message.msg ? message.msg : message\nlet mime = (message.msg || message).mimetype || ''\nlet messageType = message.mtype ? message.mtype.replace(/Message/gi, '') : mime.split('/')[0]\nconst stream = await downloadContentFromMessage(quoted, messageType)\nlet buffer = Buffer.from([])\nfor await(const chunk of stream) {\nbuffer = Buffer.concat([buffer, chunk])\n}\nlet type = await FileType.fromBuffer(buffer)\ntrueFileName = attachExtension ? (filename + '.' + type.ext) : filename\nawait fs.writeFileSync(trueFileName, buffer)\nreturn trueFileName\n}\n\nFurina.downloadMediaMessage = async (message) => {\nlet mime = (message.msg || message).mimetype || ''\nlet messageType = message.mtype ? message.mtype.replace(/Message/gi, '') : mime.split('/')[0]\nconst stream = await downloadContentFromMessage(message, messageType)\nlet buffer = Buffer.from([])\nfor await(const chunk of stream) {\nbuffer = Buffer.concat([buffer, chunk])\n}\nreturn buffer\n}\n\nFurina.getFile = async (PATH, save) => {\nlet res\nlet data = Buffer.isBuffer(PATH) ? PATH : /^data:.*?\\/.*?;base64,/i.test(PATH) ? Buffer.from(PATH.split`,`[1], 'base64') : /^https?:\\/\\//.test(PATH) ? await (res = await getBuffer(PATH)) : fs.existsSync(PATH) ? (filename = PATH, fs.readFileSync(PATH)) : typeof PATH === 'string' ? PATH : Buffer.alloc(0)\nlet type = await FileType.fromBuffer(data) || {\nmime: 'application/octet-stream',\next: '.bin'}\nfilename = path.join(__filename, './lib' + new Date * 1 + '.' + type.ext)\nif (data && save) fs.promises.writeFile(filename, data)\nreturn {\nres,\nfilename,\nsize: await getSizeMedia(data),\n...type,\ndata}}\n\nFurina.sendMedia = async (jid, path, fileName = '', caption = '', quoted = '', options = {}) => {\nlet types = await Furina.getFile(path, true)\nlet { mime, ext, res, data, filename } = types\nif (res && res.status !== 200 || file.length <= 65536) {\ntry { throw { json: JSON.parse(file.toString()) } }\ncatch (e) { if (e.json) throw e.json }}\nlet type = '', mimetype = mime, pathFile = filename\nif (options.asDocument) type = 'document'\nif (options.asSticker || /webp/.test(mime)) {\nlet { writeExif } = require('./lib/exif')\nlet media = { mimetype: mime, data }\npathFile = await writeExif(media, { packname: options.packname ? options.packname : global.packname, author: options.author ? options.author : global.author, categories: options.categories ? options.categories : [] })\nawait fs.promises.unlink(filename)\ntype = 'sticker'\nmimetype = 'image/webp'}\nelse if (/image/.test(mime)) type = 'image'\nelse if (/video/.test(mime)) type = 'video'\nelse if (/audio/.test(mime)) type = 'audio'\nelse type = 'document'\nawait Furina.sendMessage(jid, { [type]: { url: pathFile }, caption, mimetype, fileName, ...options }, { quoted, ...options })\nreturn fs.promises.unlink(pathFile)}\n\nFurina.sendText = (jid, text, quoted = '', options) => Furina.sendMessage(jid, { text: text, ...options }, { quoted })\n\nFurina.serializeM = (m) => smsg(Furina, m, store)\n\nFurina.before = (teks) => smsg(Furina, m, store)\n\nFurina.sendButtonText = (jid, buttons = [], text, footer, quoted = '', options = {}) => {\nlet buttonMessage = {\ntext,\nfooter,\nbuttons,\nheaderType: 2,\n...options\n}\nFurina.sendMessage(jid, buttonMessage, { quoted, ...options })\n}\n\nFurina.sendKatalog = async (jid , title = '' , desc = '', gam , options = {}) =>{\nlet message = await prepareWAMessageMedia({ image: gam }, { upload: Furina.waUploadToServer })\nconst tod = generateWAMessageFromContent(jid,\n{\"productMessage\": {\n\"product\": {\n\"productImage\": message.imageMessage,\n\"productId\": \"9999\",\n\"title\": title,\n\"description\": desc,\n\"currencyCode\": \"INR\",\n\"priceAmount1000\": \"100000\",\n\"url\": `${websitex}`,\n\"productImageCount\": 1,\n\"salePriceAmount1000\": \"0\"\n},\n\"businessOwnerJid\": `${ownernumber}@s.whatsapp.net`\n}\n}, options)\nreturn Furina.relayMessage(jid, tod.message, {messageId: tod.key.id})\n} \n\nFurina.send5ButLoc = async (jid , text = '' , footer = '', img, but = [], options = {}) =>{\nvar template = generateWAMessageFromContent(jid, proto.Message.fromObject({\ntemplateMessage: {\nhydratedTemplate: {\n\"hydratedContentText\": text,\n\"locationMessage\": {\n\"jpegThumbnail\": img },\n\"hydratedFooterText\": footer,\n\"hydratedButtons\": but\n}\n}\n}), options)\nFurina.relayMessage(jid, template.message, { messageId: template.key.id })\n}\nglobal.API = (name, path = '/', query = {}, apikeyqueryname) => (name in global.APIs ? global.APIs[name]: name) + path + (query || apikeyqueryname ? '?' + new URLSearchParams(Object.entries({\n    ...query, ...(apikeyqueryname ? {\n        [apikeyqueryname]: global.APIKeys[name in global.APIs ? global.APIs[name]: name]\n    }: {})\n})): '')\n\nFurina.sendButImg = async (jid, path, teks, fke, but) => {\nlet img = Buffer.isBuffer(path) ? path : /^data:.*?\\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\\/\\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)\nlet fjejfjjjer = {\nimage: img, \njpegThumbnail: img,\ncaption: teks,\nfileLength: \"1\",\nfooter: fke,\nbuttons: but,\nheaderType: 4,\n}\nFurina.sendMessage(jid, fjejfjjjer, { quoted: m })\n}\n\n            /**\n             * Send Media/File with Automatic Type Specifier\n             * @param {String} jid\n             * @param {String|Buffer} path\n             * @param {String} filename\n             * @param {String} caption\n             * @param {import('@adiwajshing/baileys').proto.WebMessageInfo} quoted\n             * @param {Boolean} ptt\n             * @param {Object} options\n             */\nFurina.sendFile = async (jid, path, filename = '', caption = '', quoted, ptt = false, options = {}) => {\n  let type = await Furina.getFile(path, true);\n  let { res, data: file, filename: pathFile } = type;\n\n  if (res && res.status !== 200 || file.length <= 65536) {\n    try {\n      throw {\n        json: JSON.parse(file.toString())\n      };\n    } catch (e) {\n      if (e.json) throw e.json;\n    }\n  }\n\n  let opt = {\n    filename\n  };\n\n  if (quoted) opt.quoted = quoted;\n  if (!type) options.asDocument = true;\n\n  let mtype = '',\n    mimetype = type.mime,\n    convert;\n\n  if (/webp/.test(type.mime) || (/image/.test(type.mime) && options.asSticker)) mtype = 'sticker';\n  else if (/image/.test(type.mime) || (/webp/.test(type.mime) && options.asImage)) mtype = 'image';\n  else if (/video/.test(type.mime)) mtype = 'video';\n  else if (/audio/.test(type.mime)) {\n    convert = await (ptt ? toPTT : toAudio)(file, type.ext);\n    file = convert.data;\n    pathFile = convert.filename;\n    mtype = 'audio';\n    mimetype = 'audio/ogg; codecs=opus';\n  } else mtype = 'document';\n\n  if (options.asDocument) mtype = 'document';\n\n  delete options.asSticker;\n  delete options.asLocation;\n  delete options.asVideo;\n  delete options.asDocument;\n  delete options.asImage;\n\n  let message = { ...options, caption, ptt, [mtype]: { url: pathFile }, mimetype };\n  let m;\n\n  try {\n    m = await Furina.sendMessage(jid, message, { ...opt, ...options });\n  } catch (e) {\n    //console.error(e)\n    m = null;\n  } finally {\n    if (!m) m = await Furina.sendMessage(jid, { ...message, [mtype]: file }, { ...opt, ...options });\n    file = null;\n    return m;\n  }\n}\nFurina.ev.on('group-participants.update', async funcs => {\n    await (await import('./gc.js'))[\"default\"](Furina, funcs);\n  });\n\nFurina.sendFileUrl = async (jid, url, caption, quoted, options = {}) => {\n      let mime = '';\n      let res = await axios.head(url)\n      mime = res.headers['content-type']\n      if (mime.split(\"/\")[1] === \"gif\") {\n     return Furina.sendMessage(jid, { video: await getBuffer(url), caption: caption, gifPlayback: true, ...options}, { quoted: quoted, ...options})\n      }\n      let type = mime.split(\"/\")[0]+\"Message\"\n      if(mime === \"application/pdf\"){\n     return Furina.sendMessage(jid, { document: await getBuffer(url), mimetype: 'application/pdf', caption: caption, ...options}, { quoted: quoted, ...options })\n      }\n      if(mime.split(\"/\")[0] === \"image\"){\n     return Furina.sendMessage(jid, { image: await getBuffer(url), caption: caption, ...options}, { quoted: quoted, ...options})\n      }\n      if(mime.split(\"/\")[0] === \"video\"){\n     return Furina.sendMessage(jid, { video: await getBuffer(url), caption: caption, mimetype: 'video/mp4', ...options}, { quoted: quoted, ...options })\n      }\n      if(mime.split(\"/\")[0] === \"audio\"){\n     return Furina.sendMessage(jid, { audio: await getBuffer(url), caption: caption, mimetype: 'audio/mpeg', ...options}, { quoted: quoted, ...options })\n      }\n      }\n      \n      /**\n     * \n     * @param {*} jid \n     * @param {*} name \n     * @param [*] values \n     * @returns \n     */\n    Furina.sendPoll = (jid, name = '', values = [], selectableCount = 1) => { return Furina.sendMessage(jid, { poll: { name, values, selectableCount }}) }\n\nreturn Furina\n\n}\ntheFontaine()\n\nprocess.on('uncaughtException', function (err) {\nconsole.log('Caught exception: ', err)\n})\n");
